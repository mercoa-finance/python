# This file was auto-generated by Fern from our API Definition.

from ...core.pydantic_utilities import UniversalBaseModel
import typing_extensions
import typing
from ...entity_types.types.entity_id import EntityId
from ...core.serialization import FieldMetadata
import pydantic
from .entity_id_or_boolean import EntityIdOrBoolean
from ...core.pydantic_utilities import IS_PYDANTIC_V2


class EntityGroupAddEntitiesRequest(UniversalBaseModel):
    """
    Examples
    --------
    from mercoa.entity_group_types import EntityGroupAddEntitiesRequest

    EntityGroupAddEntitiesRequest(
        entity_ids=[
            "ent_8545a84e-a45f-41bf-bdf1-33b42a55812c",
            "ent_21661ac1-a2a8-4465-a6c0-64474ba8181d",
        ],
    )
    """

    entity_ids: typing_extensions.Annotated[typing.List[EntityId], FieldMetadata(alias="entityIds")] = pydantic.Field()
    """
    List of entity IDs or foreign IDs to add to the group
    """

    copy_users_from: typing_extensions.Annotated[
        typing.Optional[EntityIdOrBoolean], FieldMetadata(alias="copyUsersFrom")
    ] = pydantic.Field(default=None)
    """
    Entity ID / foreign ID of an entity currently in the group to copy users and roles from OR a boolean defining if users should be copied to the new entities.
    
    If not provided or false, users and roles will not be copied.
    If true, users and roles will be copied from the entity with the most users that has been updated most recently.
    If a valid ID is provided, users and roles will be copied from the corresponding provided entity in the group.
    
    Note: If users copied, any preexisting users will be left alone, and users with the same foreign ID will not be copied.
    """

    filter_roles: typing_extensions.Annotated[typing.Optional[typing.List[str]], FieldMetadata(alias="filterRoles")] = (
        pydantic.Field(default=None)
    )
    """
    List of roles to filter users by. If not provided, all users will be copied. If provided, only users with the provided roles will be copied.
    """

    if IS_PYDANTIC_V2:
        model_config: typing.ClassVar[pydantic.ConfigDict] = pydantic.ConfigDict(extra="allow", frozen=True)  # type: ignore # Pydantic v2
    else:

        class Config:
            frozen = True
            smart_union = True
            extra = pydantic.Extra.allow
